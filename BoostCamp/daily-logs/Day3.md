# AST와 구조적 사고

## tl;dr

구조화된 데이터를 어떻게 해석하고 표현하는지 연습했다.
핵심 흐름을 파악해 재귀, 스택 등을 적용하며 구조적 사고를 정리할 수 있었다.

## 1. 이번에 알게 된 내용은?

### 1.1 AST(Abstract Syntax Tree)란?

- 입력 문자열을 **구조화된 트리 형태로 표현**할 수 있다는 개념
- 중첩된 태그나 블록 구조를 트리 구조로 재귀적으로 표현하는 데 적합

> 💡 트리는 쿼리, 탐색, 출력 등에서 유연하게 활용 가능한 구조이다

### 1.2 파서 흐름: Lexer → Parser → AST

- **Lexer**는 문자열을 토큰 단위로 자르기만 한다.
- **Parser**는 토큰을 순회하며 **트리로 변환**<br>→ 예외 처리를 담당한다.

```plaintext
문자열 → 토큰 리스트 → 노드 트리
```

> 💡 흐름이 단방향으로 연결되므로 앞단 구조가 정확해야 디버깅이 쉬움

### 1.3 핸들러 테이블 구조

- 조건 분기를 `switch` 대신 객체에 함수들을 저장해서 처리
- 
```javascript
const handlers = {
  "Open": (this, node) => { ... },
  "Close": (this, node) => { ... },
};
handlers[type](this, node);
```

- 조건문보다 가독성이 좋고, **유지보수에 유리**
- 특히 class 바깥에 두면 **단위 테스트도 수월**

> 💡 바인딩 이슈에 주의! 핸들러 안에서 `this` 사용 시 바인딩 필요

### 1.4 중첩 노드를 재귀로 순회하는 방법

- **깊이가 불확실한 중첩**은 반복문보다 재귀가 적합
- 노드가 자식 노드를 가질 수 있으므로,  `children` 필드를 기준으로 재귀 호출

```javascript
function walk(node) {
  node.children.forEach(child => {
    if (typeof ${타입 체크}) walk(child);
  });
}
```

---
## 2. 삽질 로그

### 2.1  핸들러 구조 도입 시 바인딩 문제

- 핸들러 함수가 클래스 외부에 있어서 `this` 바인딩이 깨짐
- 명시적 인자로 context 넘기는 방식으로 해결

### 2.2 중첩 순회 시 문자열 처리 누락

- `children` 안에 문자열이 섞여 있어 `typeof` 체크 없이 순회하다 오류
- 재귀 구조에서 항상 타입 체크 필요

---
## 3. 이번 학습이 남긴 것

| 항목       | 내용                         |
| -------- | -------------------------- |
| 파서 흐름 이해 | Lexer → Parser → AST 구조 파악 |
| 구조적 사고   | 중첩 구조를 재귀로 순회하는 방식 학습      |
| 핸들러 구조   | 조건 분기를 객체에 저장해 처리하는 패턴 체득  |

---
### cf. 핸들러 테이블이 좋은 이유
| 방식      | 장점                        |
| ------- | ------------------------- |
| switch  | 직관적이지만 확장성이 떨어짐           |
| handler | 깔끔한 확장, 각 타입별 함수 추출이 쉬움   |
| 재사용성    | 테스트 및 리팩토링에 유리            |
| 유지보수    | 구조가 분리되어 있어 신규 타입 추가가 용이함 |