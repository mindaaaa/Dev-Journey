# Bash와 자동화로 실전감각 익히기

## tl;dr

시스템 로그를 다루며 `Bash` 문법, 파일 권한, 리다이렉트, 그리고 외부 API 연동을 실습했고,<br>
스크립트가 제대로 작동하지 않을 때 디버깅의 중요성과 기초 명령어의 위력을 체감했다.

## 1. 이번에 알게 된 내용은?

### 1.1 Bash 배열 다루기

```bash
log_files=( $(ls -t /path/to/logs/top_*.log | head -n 5) )
```

- 배열 초기화 시 `()`로 감싸야 하며, `$(...)`는 명령어 실행 결과를 의미
- `ls -t`는 최신 순 정렬을 의미

> 💡 문자열과 배열 혼동 시 버그가 자주 발생하므로 `@`, `*` 사용법 숙지가 중요 <br>`for file in "${arr[@]}"` ← 띄어쓰기 포함된 요소도 안전하게 처리 가능

### 1.2 파일 리다이렉션의 다양한 사용법

```bash
echo "hello" > file.log    # 덮어쓰기
echo "world" >> file.log   # 이어쓰기
ls foo 2> err.log          # 오류만 저장
cat < file.txt             # 파일을 입력으로 사용
```

##### 📌 `>`와 `>>`의 차이, `2>`로 `stderr` 따로 분리 가능

> 👍 디버깅할 때 echo "..." >> debug.log 활용도가 매우 높다

### 1.3 쉘에서 조건 분기와 파이프라인 처리

```bash
if [ -z "$var" ]; then
  echo "값 없음"
fi

process=$(cat file | grep -E <<생략>> | awk <<생략>> | sort -nr | head -n 1)
```

- `-z`는 빈 문자열 체크
- 여러 명령어를 `|`로 연결해 데이터 필터링 가능
- `awk`, `sort`, `head` 등을 조합해 원하는 데이터 추출

> 💡 복잡한 파이프라인은 중간마다 echo로 확인하며 점검하는 것이 가장 빠르다.

---

## 2. 삽질 로그

### 2.1 외부 웹팩에 메시지가 안 가는 문제

- 스크립트는 성공처럼 보여도 메시지가 오지 않음
- curl -s를 제거해 오류 메시지 직접 확인해야 디버깅이 수월하다.

> 리다이렉트를 더 자유자재로 사용했다면 수월했을 것 같다.

### 2.2 로그 파싱 실패

- 로그 형식이 다소 불규칙하여 grep, awk 조건이 빈 줄까지 포함하기도 함
- 덜 복잡하고 강력하게 추출할 수 있는 정규표현식 필요

```bash
grep -E '^[[:space:]]*[0-9]+' file.log
```

> 💡 `grep -vE`로 헤더 행을 제외하고 작은 단위부터 테스트해야 덜 헷갈린다.

### 2.3 리눅스에서 복사/붙여넣기 제한

- 가상머신 터미널에서는 붙여넣기가 제한됐다.
- 긴 스크립트나 `JSON payload` 입력 시 불편

> 에디터나 툴을 찾아보고 추후 추가할 예정 🙌

---

### 3. 이번 미션이 남긴 것

| 항목       | 내용                                               |
| ---------- | -------------------------------------------------- |
| Bash 문법  | 배열, 조건문, 변수 참조 등 스크립트 구성 능력 향상 |
| 리다이렉트 | `>`, `>>`, `2>` 등 입출력 조작 방식 숙지           |
| 디버깅     | 중간 결과를 출력하며 흐름 추적하는 습관 형성       |

---

### cf. 리다이렉트의 모든 것

쉘에서 입력/출력 방향을 바꾸는 기능을 `리다이렉트`라고 부른다.

| 기호 | 기능                     | 설명                                           |     |
| ---- | ------------------------ | ---------------------------------------------- | --- |
| `>`  | **출력 덮어쓰기**        | 명령어 결과를 파일로 저장 (기존 내용은 사라짐) |     |
| `>>` | **출력 이어쓰기**        | 기존 파일 끝에 내용을 추가 (append)            |
| `<`  | **입력 리다이렉트**      | 파일 내용을 명령어 입력으로 사용               |
| `2>` | **에러 출력 리다이렉트** | stderr(표준 오류 출력)을 파일로 저장           |
| \`   | **파이프**               | 명령어 출력을 다음 명령어의 입력으로 전달      |
