---
title: 점화식 개념과 구조 체화 – DP 응용의 출발점
date: 2025-04-19
tags: [algorithm, dp, recurrence, til, tabulation, memoization]
draft: false
description: 계단 오르기, 타일링, 멀리 뛰기 문제를 통해 점화식 구성과 확장 사고를 훈련하고, 재귀 vs 반복 방식 차이와 순서 조건의 의미까지 체득한 기록
---
`목표` 점화식 개념 이해

## 📌  학습 목표

- DP에서의 **점화식 개념**을 정확히 이해한다.
- **점화식 응용 문제**를 직접 따라 풀며 사고력을 키운다.
- 점화식 구현에 필요한 **초기값 설정**과 **반복/재귀 방식의 차이**를 익힌다.

## 학습 목록

| 주제             | 내용                                                  |
|------------------|-------------------------------------------------------|
| 점화식 개념 이해 | 피보나치 구조에서 파생되는 문제를 통해 사고방식 학습          |
| 계단 오르기       | 점화식: `dp[n] = dp[n - 1] + dp[n - 2]`              |
| 타일링 문제       | 점화식: `dp[n] = dp[n - 1] + dp[n - 2]`              |
| 실제 코딩문제      | 프로그래머스 `멀리 뛰기` 문제                        |

## 실습

- [x] 계단 오르기 (Hand-coding / 점화식 직접 세워보기)
- [x] 타일링 문제 (`2×n` 크기 채우기)
- [x] [멀리 뛰기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

## 자가 점검

- [x] 피보나치 구조가 다양한 문제로 **확장될 수 있음**을 이해했는가?
- [x] 점화식의 조건과 초기값을 직접 설정해볼 수 있는가?
- [x] **Tabulation vs Memoization**의 구조 차이를 비교해봤는가?
- [x] 점화식 흐름을 **손으로 써보며 계산 과정**을 익혔는가?

## 🧩🧩 마무리하며

- [x] `계단 오르기`, `타일링`, `멀리 뛰기` 문제의 **점화식 구조는 어떻게 달랐는가?**
- [x] `반복문` 기반의 Tabulation 코드와 재귀 기반의 Memoization 코드를 **직접 비교**해봤는가?
- [x] **내일은 조금 더 복잡한 조건이 붙는 DP 문제로 확장할 수 있을까?**

> 오늘은 점화식을 정확히 세우는 감각을 다졌다면,  
> 내일은 조건 분기와 조합이 더 어려운 문제로 레벨업할 수 있도록 준비하자! 🚀

---

# 📌 오늘의 회고

`Today I Learned` 점화식 & DP 자신감 UP! 

## 📌 오늘의 키워드 

- [x] 점화식 패턴 익히기
- [x] Top-Down & Bottom-Up 구조 체득
- [x] **순서가 중요한/중요하지 않은 문제 구분**
- [x] **DP + 다른 알고리즘 혼합문제의 출발점 잡기**

## 😨 DP, 수포자에겐 너무 어려운 거 아닌가?

- 점화식이 등장한다는 말에 *수포자였던 나*는 반신반의하며 학습을 시작했다.  <br>*"내가 이해나 할 수 있을까?"* 싶었지만...

### 🙀 현실은?

> 생각보다 정형화된 **패턴**으로 해결되는 구조였고,  
> 심화문제는 오히려 **DP 단독**보다는  
> **DP + 다른 알고리즘**을 혼합한 문제에 가깝다는 걸 느꼈다.

## ✍️ 직접 손으로 써보며 감 잡기

- `계단 오르기`, `타일링`, `멀리뛰기`, `동전 문제`까지  
  기본 문제를 손코딩하면서 **패턴**을 익혔다.
- 처음엔 `Bottom-Up` 방식으로 시작하여 전체 흐름을 이해하고,  
  이후에는 `Top-Down`으로 다시 구현하며  
  **메모이제이션 재귀의 고통**도 몸소 느껴봤다 🤯

### 🙅‍♀️ 재귀만 쓰면 어떤 일이 벌어졌을까?

```javascript
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}
```
- 단순하게 구현할 수 있지만, 동일한 `fib(n)`을 **수없이 반복 호출**하게 된다.
>  → **O(2^n)** 복잡도로 인해 성능이 _터진다_ 💣

### 🙆‍♂️ 메모이제이션 도입 후

```javascript
const memo = {};

function fib(n) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  return (memo[n] = fib(n - 1) + fib(n - 2));
}
```
- 이미 구한 값을 저장하고, 다시 계산하지 않는다!
- 콜스택 깊이가 여전히 부담될 수는 있지만  훨씬 **성능이 개선**된다.
    
## 🤯 사고 확장의 순간

- 거스름돈 문제를 풀며 기존엔 DFS로 내려가는 흐름만 떠올렸다.

```javascript
// DFS 방식으로 동전 만들기
const pick = dfs(i, total - coins[i]); // 같은 동전 계속 사용
const skip = dfs(i + 1, total);        // 다음 동전으로 이동
```
<br>그런데...

```javascript
// 점화식 기반
dp[i] = dp[i - 1] + dp[i - 2];
```

> ❗ 이건 `정답(끝)`을 기준으로 문제를 바라보는 사고방식이다!

> → **정답을 만드는 경로**가 무엇인지 거꾸로 추적하며,  
수식을 유도한다는 사실이 너무 신기했다.

## 순서의 중요성

### 🚨 순서가 중요한 경우 (계단 오르기)

```javascript
// 계단 오르기 - 1칸, 2칸씩 올라갈 수 있음
for (let i = 2; i <= n; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}
```
- 3칸 올라가는 방법: `[1,2]`, `[2,1]`, `[1,1,1]`
> → 서로 **다른 경로**로 간주됨
    

### 🚨 순서가 중요하지 않은 경우 (동전 문제)

```javascript
for (let coin of coins) {
  for (let i = coin; i <= target; i++) {
    dp[i] += dp[i - coin];
  }
}
```
- 동전 `{1, 2}`로 `4`를 만드는 경우   `[2,2]`, `[1,1,2]`, `[1,2,1]` …  

>순서를 고려하지 않고 **같은 구성은 한 번만 카운트**해야 하므로  
>**바깥 for문이 coin 기준**이다!

## 🎯 내일의 목표 (심화편)

> 이제는 1차원 배열을 넘어  
> **2차원 배열 기반의 점화식**을 이해하고 구현하는 것이 목표!

### 📌 학습 예정 주제

| 개념                | 내용                               |
| ----------------- | -------------------------------- |
| LCS (최장 공통 부분 수열) | 문자열 비교 기반 DP 문제                  |
| 2차원 DP 테이블 구성     | `dp[i][j]` 형태로, 상태를 2가지 이상으로 나누기 |
| 점화식으로 문자열 관계 유도   | 한 문자씩 비교하며 점화식 도출                |
| 상태 추적/결과 재구성      | LCS 경로를 추적하거나 부분 문자열 출력          |

## 🙇‍♂️ 마무리하며

- DP가 단순 암기 영역이 아닌 `패턴과 사고의 전환`이라는 걸 깨달았다
- 특히 `Top-Down`은 _재귀 감각이 필요하고_, `Bottom-Up`은 _패턴에 집중해야 한다_
    
> 점화식이 어렵게 느껴졌지만, 오늘 하루를 통해  
   **점화식을 내 손으로 직접 다룰 수 있다는 자신감**이 생겼다 💪

> 역시 손코딩을 하다보면
> **어느새 머릿속에 그려지는 순간**이 찾아오는 것 같다🔥🔥