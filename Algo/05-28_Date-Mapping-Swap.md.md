---
title: 날짜 계산, 양방향 해시, 구조 분해 스왑으로 최적화된 풀이
date: 2025-05-28
tags:
  - date
  - hashmap
  - swap
  - optimization
  - structure
  - 코딩테스트
draft: false
summary: 날짜를 정수로 처리해 비교 단순화, 배열-해시 양방향 동기화로 O(N+M) 풀이. 구조 분해 할당으로 배열 요소 스왑 최적화.
---
## 📌 인사이트 요약

- 문자열 split과 map, 구조 분해 할당을 통해 코드 가독성을 높일 수 있다🔥
- 배열과 객체(해시)를 동시에 사용하는 **양방향 매핑 구조** 설계가 중요
- 단순 `splice`나 `indexOf`는 시간복잡도 측면에서 **코딩 테스트 탈락 요소**<br> → `forEach + 객체 갱신` 방식으로 **O(N)** 시간 복잡도 달성 가능

---
# 오늘의 문제

### ▸ 개인정보 수집 유효기간

- 날짜 계산을 위해 28일로 환산
- 개인정보 수집일과 유효기간 기준으로 만료 여부 판단

### ▸ 유연근무제

- 5일 모두 시간 안에 출근하면 상품

### ▸ 달리기 경주

- callings 배열은 추월한 선수들의 이름 나열
- 추월할 때마다 **현재 선수와 바로 앞 선수의 순서를 바꿈**

---
# 인사이트

### 1. 날짜를 정수로 바꿔 비교하면 굉장히 간결해진다

```javascript
const totalDays = year * 12 * 28 + month * 28 + day;
```
- **문자열을 직접 날짜 객체로 다루기보다는**, 조건이 명확할 땐 **정수화하여 비교**하는 게 훨씬 편리하고 빠름

> **TIP** 날짜 계산이 복잡할수록 `일 단위로 통일`하면 로직이 단순해짐

### 2. 결과 배열은 `push`로 직접 추가하는 것이 가장 깔끔

```javascript
if (daysSinceCollection >= validDurationInDays) {
  result.push(index + 1);
}
```

- 객체를 만들어서 `.entries() → .filter() → .map()` 식으로 처리하는 방식보다 단순하고 효율적
- **index를 그대로 결과로 쓰는 문제**에서는 배열이 가장 적절📌

### 3. 중간 변수는 꼭 필요할 때만 선언

- `parsedPrivacies` 같은 중간 배열을 만들지 않고, forEach나 map 안에서 바로 로직을 작성하는 게 **코테 기준 정석**
- 필요 이상으로 메모리를 쓰지 않는 것이 **최적화의 첫걸음**

### 4. 등수 배열과 해시를 동기화
```javascript
const players = ['mumu', 'soe', 'poe'];
const rank = { mumu: 0, soe: 1, poe: 2 };
```

- `players[]`: 등수 → 이름
- `rank{}`: 이름 → 등수

> 서로 보완 관계인 두 구조를 사용하면 O(1) 접근이 가능

### 5. 구조 분해 할당으로 swap

```javascript
[players[prev], players[idx]] = [players[idx], players[prev]];
```
- 기존에 `temp` 변수로 일일이 바꾸던 과정을 한 줄로 압축
- 가독성 높고, 실전에서도 유용하게 사용됨

> **TIP** 성능은 O(1)이다

### 6. 해시 갱신까지 함께

```javascript
rank[player] = prev;
rank[beforePlayer] = idx;
```

- swap 후 `players[]` 배열만 바꾸면 **rank가 꼬임**
- 반대로 `rank{}`만 바꾸면 **배열이 꼬임**<br>➜ 항상 **둘 다 함께 변경**해야 함!

## 시간 복잡도 분석

|연산|시간 복잡도|
|---|---|
|초기 rank 해시 생성|O(N)|
|callings 순회 + swap|O(M)|
|전체 최종 결과 return|O(1)|

>**총 시간복잡도** `O(N + M)`

> `N`: 선수 수, `M`: 호출 수  
> 최대 50,000명 × 1,000,000번이라도 버틸 수 있다😆

---
## 📌 배운 점

- **양방향 접근이 필요할 땐 배열 + 해시 조합**이 매우 강력🔥🔥
- 구조 분해 할당을 활용한 **배열 요소 스왑**은 성능과 가독성 모두에 이점
- 해시와 배열을 쌍으로 설계할 땐, 항상 *동기화 유지*에 주의할 것
- `.forEach()` 내에서 자료구조만 잘 갱신하면 복잡한 연산 없이도 **순서 보장 가능**
