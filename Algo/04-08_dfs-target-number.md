---
title: DFS 개념 이해와 타겟 넘버 문제 풀이
date: 2025-04-08
tags: [algorithm, dfs, recursion, 백트래킹, til]
draft: false
description: DFS의 기본 개념과 재귀 흐름, 타겟 넘버 문제 실습을 통해 깊이우선탐색 구조와 백트래킹 조건을 체득한 학습 정리
---
`목표` DFS 개념 + 재귀 패턴 이해

## 📌 학습 목표

- DFS(깊이 우선 탐색)의 **기본 개념과 흐름**을 이해한다  
- 재귀 함수로 DFS를 구현하며 **호출 스택의 구조**를 체득한다  
- `타겟 넘버` 문제를 통해 실전 DFS 흐름을 연습한다  
- 백트래킹과 DFS의 차이를 구분하고, **가지치기 조건 유무**를 확인한다

## 학습 목록

| 주제             | 설명                                               |
| -------------- | ------------------------------------------------ |
| DFS (깊이 우선 탐색) | 하나의 경로를 끝까지 파고들며 탐색하는 방식 *재귀 or 스택 기반*           |
| 재귀함수           | 자기 자신을 호출하는 함수 *DFS 구현의 핵심*                      |
| 백트래킹           | 유망하지 않은 경로를 미리 잘라내는 기술  *DFS의 효율화 기법*            |
| 호출 스택          | 재귀 함수 호출 시 쌓이는 함수들의 순서 구조 <br>⚠️⚠️ DFS 흐름 이해에 중요 |

## 실습 

| 문제    | 유형        | 목표                               |
| ----- | --------- | -------------------------------- |
| 타겟 넘버 | DFS 재귀 탐색 | DFS 흐름 파악 + 가지치기 없는 완전탐색 구조 이해하기 |

## 자가 점검

- [x] DFS 함수는 어떤 구조로 만들어야 할까? (`dfs(depth, sum)` 등)
- [x] 가지치기가 불가능한 문제는 어떤 구조일까?
- [x] DFS에서 **재귀 호출**과 **복귀 시점**은 어떻게 구분될까?
- [x] 백트래킹 조건을 걸 수 있는 DFS 문제는 어떤 예시가 있을까?

## ✨ 마무리하며

- [x] DFS 템플릿을 직접 작성해보았다
- [x] 호출 스택 흐름을 손코딩/출력 로그로 확인해보았다
- [x] 타겟 넘버 문제를 재귀 DFS로 직접 구현해보았다
- [x] 백트래킹이 힘을 발휘하는 경우를 명확하게 정리했다

> 오늘은 **DFS 개념의 뼈대와 흐름**을 익히는 날!  
> 이번 주는 단순 탐색(`순열/조합`)이 아니라
> `문제 조건을 만족시키는 정답`을 구하는 DFS에 딥다이브🏄 해보자!!

---

# 📌 오늘의 회고

`Today I Learned` DFS와 재귀 패턴

- [x] 가지치기가 불가능한 경우를 체득했는가?
- [x] DFS에서 **재귀 호출**과 **복귀 시점**은 어떻게 구분되는지 체득했는가?
- [x] 백트래킹 조건을 걸 수 있는 DFS 문제는 어떤 예시가 있을까?
- [x] 호출 스택 흐름을 손코딩/출력 로그로 확인해보았는가?


## 오늘의 배운 점 

| 주제                        |
| ------------------------- |
| DFS 개념 + 재귀 패턴 이해         |
| `depth`의 역할과 DFS의 흐름 이해하기 |
- 지난주 **완전탐색 / 순열 / 조합** 학습에서는 `depth` 없이 재귀를 구성했기에 `depth`의 역할을 정확히 파악하지 못했다.
- 하지만 **타겟 넘버** 문제를 통해 `depth`의 진짜 쓰임을 체감하게 됐다🔥🔥

## 🧘 깨달은 점
### `depth`는 왜 필요한가?

- 단순히 반복문 `i`로 충분할 거라고 생각했으나, 타겟 넘버 문제에서는 재귀 단계마다 `어떤 인덱스의 숫자를 사용할지 기억`해야 하기 때문에 `depth`가 필수

```js
dfs(depth + 1, sum + numbers[depth]);
dfs(depth + 1, sum - numbers[depth]);
```

- `numbers[depth]`처럼 **명확하게 인덱스를 지정**할 수 있어서  
    **모든 숫자를 정확히 한 번씩** 사용할 수 있다.
### 언제 무슨 요소를 사용하는가?

| 요소            | 사용 조건                     |
| ------------- | ------------------------- |
| `depth`       | 인덱스 기반으로 탐색 단계가 중요한 경우    |
| `start`       | 조합처럼 **중복 없이** 이후 값들만 볼 때 |
| `path.length` | 길이가 종료 조건일 때 `r개 뽑기`      |

> ✅ 조합/순열 문제는 `길이` 기준 → `path.length`  
> ✅ 타겟 넘버는 `인덱스 순서` 기준 → `depth`

### DFS와 백트래킹

DFS는 **탐색 방법**이고,  
백트래킹은 *불필요한 경로를 사전에 잘라내는 전략*이다.

```javascript
if (조건 위반) return; // ⚠️ 가지치기
```

하지만 타겟 넘버 문제처럼 **끝까지 계산하지 않으면 정답 여부를 알 수 없는 경우**,  
**백트래킹이 불가능**하기 때문에 **완전한 DFS 탐색**이 필요했다😂

### 재귀 호출과 복귀 시점 알아보기

DFS는 호출이 중첩되며 *스택 구조*로 동작한다.
복귀할 때는 반드시 *상태를 원래대로 복원*해야 한다.

```javascript
path.push(val);
visited[i] = true;

// console.log("재귀 호출 전:", visited);
dfs(...);

path.pop();
visited[i] = false; // ⚠️ 상태 복원
// console.log("재귀 복귀 후:", visited);
```

## ⚙️ 구현 코드

```javascript
function solution(numbers, target) {
  let count = 0;

  function dfs(depth, sum) {
    if (depth === numbers.length) {
      if (sum === target) count++;
      return;
    }

    dfs(depth + 1, sum + numbers[depth]);
    dfs(depth + 1, sum - numbers[depth]);
  }

  dfs(0, 0);
  return count;
}
```

## 🎯 내일의 목표

| 주제                                     | 문제       |
| -------------------------------------- | -------- |
| DFS 구현 연습 <br> - 백트래킹<br> - visited 배열 | **네트워크** |

> 오늘은 DFS 구조를 감각적으로 이해한 날🏄
> 내일은 백트래킹과 `visited 배열`을 활용한 DFS를 체득할 예정이다.

 > **DFS 구현 + visited + 백트래킹** 이 3박자를 익히면  
 > **그래프 탐색 문제의 기본 체력을 완성하게 되는 것!** 💪💪
> 드디어 **그래프 탐색** 세계로 입성한다 흐흐흐...🔥
