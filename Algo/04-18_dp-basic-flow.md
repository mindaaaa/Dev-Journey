---
title: DP 기본 개념과 흐름 정리 – 피보나치로 이해하는 Top-Down과 Bottom-Up
date: 2025-04-18
tags: [algorithm, dp, fibonacci, memoization, bottom-up, til]
draft: false
description: 피보나치 수열을 통해 동적 계획법의 핵심 흐름과 점화식 구성, 메모이제이션과 타뷸레이션의 차이를 체감하며 학습한 기록
---
`목표` DP의 기본 개념과 *흐름* 정리

## 📌 학습 목표

- **DP의 기본 개념**과 핵심 흐름 정리
- `Top-Down`, `Bottom-Up` 방식의 차이점 이해
- `피보나치 수열`을 바탕으로 `점화식 구성 → 손코딩` → 감각 익히기

## 학습 목록

| 개념           | 내용                                 |
| ------------ | ---------------------------------- |
| DP 기본 흐름     | 재귀 vs DP 차이점 정리                    |
| Top-Down 방식  | 메모이제이션 구조 이해 및 호출 순서 따라가기          |
| Bottom-Up 방식 | 테이블(dp 배열) 작성 순서 직접 손코딩            |
| 점화식 감각 훈련    | `점화식이란?` 정의 → 피보나치 점화식 구조 직접 만들기   |
| 실습           | `fib(5)` 호출 흐름 손으로 그려보기, dp 배열 채우기 |

## 실습

- [x] `fib(5)`의 재귀 호출 트리를 직접 그려본다
- [x] Top-Down에서 `memo[n]`이 저장되는 순서를 표로 그려본다
- [x] Bottom-Up에서 `dp[i]` 배열을 직접 채워본다
- [x] 점화식의 개념을 정리하고, 피보나치 점화식을 적어본다

## 자가점검

- [x] DP와 재귀 함수는 어떻게 다를까?
- [x] `점화식`은 무엇이며 언제 필요한가?
- [x] 피보나치 수를 3가지 방식(재귀/메모이제이션/바텀업)으로 설명할 수 있는가?
- [x] 재귀 호출과 반복문 구현의 차이를 이해했는가?

## 🧩🧩 내일은···.

- **계단 오르기 / 타일링 문제**로 **점화식 직접 세우기 실습**
- **패턴 파악** & 점화식 응용 훈련 시작!

> 오늘은 DP의 핵심을 꿰뚫고,  
> 내일부터는 진짜 문제에 적용하는 실전 로직 훈련을 시작하자! 🔥

---

# 📌 오늘의 회고

`Today I Learned` DP의 기본 개념과 *흐름* 정리

- [x] 동적 계획법 (DP)
- [x] 메모이제이션 vs 타뷸레이션
- [x] 피보나치 수열
- [x] 오버플로우 / MOD 연산

## 배운 점 

> **메모이제이션과 동적 계획법은 '선택지'가 아닌 포함 관계!**  

-  DP의 한 방식으로 메모이제이션이 존재한다는 걸 이번에 처음 알게 됐고,  
  이전까지는 '둘 중 어떤 걸 써야 하나?' 고민했던 사고방식이 정리 됐다.

  약간 부끄러웠지만 지금 알았으니 되었다😂

> **피보나치 수를 기준으로 DP의 흐름을 따라가며**  

- 메모이제이션 → 타뷸레이션으로 이어지는 호출 순서를 익히다 보니  
  `왜 타뷸레이션이 더 효율적인지` 체감되었다.

> 함수 호출은 생각보다 **⚠️훨씬 무겁다⚠️**

- 특히 재귀 호출은 `콜스택, 함수 실행, 메모리 등` 시스템에 부담이 크기 때문에  
  단순 for문을 돌며 *Bottom-Up*으로 접근하는 타뷸레이션이 **성능상 훨씬 우수하다는 사실**을 처음 알았다👀  
  알고리즘이 점점 시스템 사고로 확장되는 기분이 들었달까..? 🔥🔥

> [피보나치 수](https://school.programmers.co.kr/learn/courses/30/lessons/12945?itm_content=course14743) 문제를 풀면서

- 정답이라고 확신했던 코드가 다수의 테스트케이스에서 실패했을 때 멘붕💥...  
- 그런데 알고보니 이건 단순한 코드 오류가 아니라 **숫자의 정확도(오버플로우)** 때문이었다는 걸 깨달았다.

```javascript
// 이 코드가 왜 틀릴까?
return fib(n);
```

- JS의 `Number`는 `2^53` 이상이면 정확도가 깨진다.  
    그래서 문제에 주어진 `1234567`로 **mod 연산**을 해야 했던 것!  
    전공 수업에서 *오버플로우 조심하자*란 가르침을 들었지만,  
    이걸 진짜 체감한 건 이번이 처음이었다.
```javascript
for(let i=2; i<=n; i++){
	dp[i] = (dp[i-1] + dp[i-2]) % 1234567;
}
```

## 🧘  깨달은 점

- DP는 단순 암기가 아닌 **패턴 감각**이 중요하다. 
> 각 방식이 **언제 더 나은지 판단할 수 있어야** 한다.

- 성능 최적화를 위해 **mod 연산, overflow 방지**는 필수!
> 계산값을 구하면서 mode 처리를 해야 한다.
    
- 생각보다 실전 코딩은 구현보다 조건 읽기가 더 어렵다.  
> **문제를 꼼꼼하게 읽자...!** 🙏

## ⚙️ 구현 코드
```javascript
function solution(n) {
    function fib(n){
        const dp = [0, 1];
        
        for(let i=2; i<=n; i++){
            dp[i] = (dp[i-1] + dp[i-2]) % 1234567;
        }
        
        return dp[n];
    }
    
    return fib(n);
}
```
## 🎯 내일의 목표

- 계단 오르기, 타일링 문제를 통해 **점화식 훈련**
- 다양한 유형의 점화식을 **직접 손코딩**
- **멀리 뛰기 문제 실전 풀이**로 점화식 감각 완성하기
    
> 오늘은 DP의 개념과 효율성을 실제로 느껴본 하루!  
> 내일은 직접 문제를 풀며 **점화식을 몸에 익혀보자🔥**